#pragma once

#include <atomic>
#include <iostream>
#include <cassert>
#include <format>

namespace posix_ipc
{
namespace queues
{
/// @brief Storage for SPSCQueue.
/// @details
/// This struct is used to store the read and write indices of the queue.
/// It also stores the size of the buffer and the offset to the buffer.
/// The buffer is stored in shared memory right after the storage object.
struct SPSCStorageStatic
{
    static constexpr size_t CACHE_LINE_SIZE = 64;

    alignas(CACHE_LINE_SIZE) const size_t storage_size; // size of storage in bytes
    alignas(CACHE_LINE_SIZE) const size_t buffer_size;  // size of data buffer in bytes
    alignas(CACHE_LINE_SIZE
    ) const ptrdiff buffer_offset; // offset from start of SPSCStorage to buffer

    alignas(CACHE_LINE_SIZE) std::atomic<size_t> read_ix;
    alignas(CACHE_LINE_SIZE) std::atomic<size_t> write_ix;

    SPSCStorageStatic(
        const size_t storage_size__, const size_t buffer_size__, const ptrdiff buffer_offset__
    )
        : storage_size(storage_size__),
          buffer_size(buffer_size__),
          buffer_offset(buffer_offset__),
          read_ix(0),
          write_ix(0)
    {
    }
};

static_assert(sizeof(SPSCStorageStatic) == 5 * SPSCStorage::CACHE_LINE_SIZE, "");

/// @brief A lock-free, single-producer, single-consumer queue.
/// @details
/// This queue is a circular buffer with a fixed capacity.
/// It supports variable sized messages.
/// It is a single-producer, single-consumer queue, meaning that one thread
/// can push to the queue and one thread can pop from the queue
/// without any synchronization.
///
/// A message consists of a header and a payload. The header contains
/// the size of the payload as uint32 (4 bytes long). The payload
/// contains the actual data.
///
/// Please note that the capacity of the queue must be at least twice
/// the maximum message size.
///
/// Implementation details
/// ----------------------
/// If (read_ix == writeIdx), the queue is considered empty.
/// If (writeIdx + message size) would cross read_ix,
/// the queue is considered full and publish will return false.
///
/// If the message crosses the end of the buffer, it is instead written
/// at the beginning if there is sufficient space available.
/// At the current write index, a header with size 0 is written to indicate
/// that the message wraps around.
template <typename T>
class SPSCQueueStatic
{
private:
    alignas(SPSCStorage::CACHE_LINE_SIZE) SPSCStorageStatic* storage_;
    alignas(SPSCStorage::CACHE_LINE_SIZE) T* buffer_;
    const size_t capacity_ = 0;

public:
    SPSCQueueStatic(SPSCStorageStatic* storage)
        : storage_(storage), capacity_(storage->buffer_size / sizeof(T))
    {
        buffer_ = reinterpret_cast<T*>(reinterpret_cast<byte*>(storage) + storage->buffer_offset);
    }

    ~SPSCQueueStatic()
    {
        // NOTE: destructor not needed since memory is allocated in shared memory for whole object
        // delete[] buffer_;
    }

    // non-copyable & non-movable
    SPSCQueueStatic(const SPSCQueueStatic&) = delete;
    SPSCQueueStatic& operator=(const SPSCQueueStatic&) = delete;
    SPSCQueueStatic(SPSCQueueStatic&&) = delete;
    SPSCQueueStatic& operator=(SPSCQueueStatic&&) = delete;

    inline size_t capacity() const
    {
        return capacity_ - 1; // one slot is always empty
    }

    // inline size_t read_ix() const
    // {
    //     return storage_->read_ix.load(std::memory_order::relaxed);
    // }

    // inline size_t write_ix() const
    // {
    //     return storage_->write_ix.load(std::memory_order::relaxed);
    // }

    bool enqueue(const T& val) noexcept
    {
        size_t write_ix = storage_->write_ix.load(std::memory_order::relaxed);

        auto next_write_ix = write_ix + 1;
        if (next_write_ix == capacity_)
            next_write_ix = 0;

        auto read_ix = storage_->read_ix.load(std::memory_order::acquire);
        if (next_write_ix == read_ix)
            return false; // queue full

        // write to buffer
        buffer_[write_ix] = val;

        // update write index
        storage_->write_ix.store(next_write_ix, std::memory_order::release);

        return true; // success
    }

    bool dequeue(T& val) noexcept
    {
        auto read_ix = storage_->read_ix.load(std::memory_order::relaxed);
        auto write_ix = storage_->write_ix.load(std::memory_order::acquire);

        if (read_ix == write_ix)
            return false; // queue empty

        // next read index
        auto next_read_ix = read_ix + 1;
        if (next_read_ix == capacity_)
            next_read_ix = 0;

        // read message
        val = buffer_[read_ix];

        // update read index
        storage_->read_ix.store(next_read_ix, std::memory_order::release);

        return true;
    }
};
} // namespace queues
} // namespace posix_ipc
